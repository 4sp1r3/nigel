# Genetic Programming with DEAP

## Data Structures

### Primitive Tree

Tree specifically formatted for optimization of genetic
programming operations. The tree is represented with a
list where the nodes are appended in a depth-first order.
The nodes appended to the tree are required to
have an attribute *arity* which defines the arity of the
primitive. An arity of 0 is expected from terminals nodes.
    
### Primitve

Class that encapsulates a primitive and when called with arguments it
returns the Python code to call the primitive with the arguments.

### Terminal

Class that encapsulates terminal primitive in expression. Terminals can
    be values or 0-arity functions.

### Ephemeral

Class that encapsulates a terminal which value is set when the
    object is created. To mutate the value, a new object has to be
    generated. This is an abstract base class. When subclassing, a
    staticmethod 'func' must be defined.
   
### PrimitiveSetTyped

Class that contains the primitives that can be used to solve a
    Strongly Typed GP problem. The set also defined the researched
    function return type, and input arguments type and number.
    
### PrimitiveSet    

Class same as _PrimitiveSetTyped__, except there is no
    definition of type.
  

## Tree Generation Functions

### generate

Generate a Tree as a list of lists. The tree is built
    from the root to the leaves, and it stop growing when the
    condition is fulfilled.

### genFull

Generate an expression where each leaf has a the same depth
    between *min* and *max*.
    
### genGrow

Generate an expression where each leaf might have a different depth
    between *min* and *max*.
    
### genHalfandHalf

Generate an expression with a PrimitiveSet *pset*.
    Half the time, the expression is generated with :func:`~deap.gp.genGrow`,
    the other half, the expression is generated with :func:`~deap.gp.genFull`.


## Tree Crossover Functions 

### cxOnePoint

Randomly select in each individual and exchange each subtree with the
    point as root between each individual.
    
### cxOnePointLeafBiased

Randomly select a crossover point in each individual and exchange each
    subtree between each individual.

The parameter *termpb* sets the probability to choose between a terminal
or non-terminal crossover point. For instance, as defined by Koza, non-
terminal primitives are selected for 90% of the crossover points, and
terminals for 10%, so *termpb* should be set to 0.1.


## Tree Mutation Functions

### mutUniform

Randomly select a point in the tree, then replace the
subtree at that point as a root by the expression generated by the given function

### mutNodeReplacement

Replaces a randomly chosen primitive from *individual* by a randomly
    chosen primitive with the same number of arguments from the :attr:`pset`
    attribute of the individual.
    
### mutEphemeral

This operator works on the constants of the tree *individual*. In
    *mode* ``"one"``, it will change the value of one of the individual
    ephemeral constants by calling its generator function. In *mode*
    ``"all"``, it will change the value of **all** the ephemeral constants.

### mutInsert

Inserts a new branch at a random position in *individual*. The subtree
    at the chosen position is used as child node of the created subtree, in
    that way, it is really an insertion rather than a replacement. Note that
    the original subtree will become one of the children of the new primitive
    inserted, but not perforce the first (its position is randomly selected if
    the new primitive has more than one child).

### mutShrink

This operator shrinks the *individual* by chosing randomly a branch and
    replacing it with one of the branch's arguments (also randomly chosen).

    
## Tree Compilation Functions

### compile

Compile an expression.  It can either be a PrimitiveTree,
 a string of Python code or any object that when
 converted into string produced a valid Python code
 expression.
 
### compileADF

Compile the expression represented by a list of trees. The first
    element of the list is the main tree, and the following elements are
    automatically defined functions (ADF) that can be called by the first
    tree.
    
    
## Evolutionary Algorithms

### eaSimple

This algorithm reproduces the simplest evolutionary algorithm as
    presented in chapter 7 of [Back2000]_.  The algorithm takes 
    in a population and evolves it in place using the both mutation
    and crossover.

### eaMuPlusLambda

This is the `(\mu + \lambda)` evolutionary algorithm.

This variation is named *Plus* because of its propention to apply both
    crossover and mutation on the individuals. Note that both operators are
    not applied systematically, the resulting individuals can be generated from
    crossover only, mutation only, crossover and mutation, and reproduction
    according to the given probabilities. Both probabilities should be in
    :math:`[0, 1]`.

### eaMuCommaLambda

This is the `(\mu~,~\lambda)` evolutionary algorithm.

This variation will never result from both operations crossover and mutation. 
The sum of both probabilities shall be in :math:`[0, 1]`, the reproduction probability is
    1 - *cxpb* - *mutpb*.
    
### eaGenerateUpdate

This is algorithm implements the ask-tell model proposed in
    [Colette2010]_, where ask is called `generate` and tell is called `update`.
    
The algorithm generates the individuals using the `toolbox.generate`
    function and updates the generation method with the `toolbox.update`
    function.
